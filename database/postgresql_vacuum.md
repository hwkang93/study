# Vacuum

PostgreSQL에서는 UPDATE나 DELETE 작업 대상이 된 해당 자료의 옛 버전을 작업 완료 후 바로 버리지 않는다.
이 작업은 다중 버전 동시성 제어(multiversion concurrency control, MVCC) 기법을 구현하는데 이점이 있기 때문이다.
삭제된 자료를 다른 트랜잭션에서 사용하고 있다면, 그 자료가 삭제되면 안되기 때문이다.
하지만, 다른 트랜잭션이 더 이상이 그 옛 버전 자료에 대한 접근이 필요 없다면, 옛 버전 자료는 쓸모 없는 자료가 된다.
이 상태로 계속 운영 된다면, 디스크에는 쓸모 없는 자료들이 넘처나게 될 것이다.
이런 더 이상 사용할 수 없는, 사용해서는 안될 자료들을 정리해서 그 자료가 있었던 공간을 빈 공간으로 바꾸는 작업을 VACUUM 이라고 한다.


## VACUUM 과 VACUUM FULL

VACUUM 은 VACUUM 과 VACUUM FULL 로 나눌 수 있다.

VACUUM 기본 작업은 테이블과 인덱스에서 삭제된 자료 (old version row, dead row 라고 한다) 를 정리하고, 그 자리를 다른 자료가 저장 될 수 있도록 빈공간으로 표시하는 것이다.
하지만, 이 작업은 운영체제 입장에서의 디스크 여유 공간을 확보하는 것을 의미하지는 않는다.
물론 한 테이블의 자료가 모두 지워졌고, 하나 또는 소수의 페이지만 없애면 되는데,
이 작업을 위해 테이블 전체의 배타적 잠금도 쉽게 할 수 있는 상황과 같이 특별한 경우는 해당 페이지를 삭제 해서 운영체제 입장의 디스크 여유 공간을 확보할 수도 있다.

이와 반대로, VACUUM FULL 작업은 해당 테이블의 사용할 수 있는 자료들만을 따로 모아 아에 새 파일에 저장하는 방식을 이용하기 때문에 운영체제 입장에서 디스크 여유 공간을 확보할 수 있다.
작업 결과로 해당 테이블에 대해서 최적의 물리적 크기로 테이블이 만들어진다.
하지만 그 작업은 일반 VACUUM 작업에 비해 시간이 꽤 걸린다.
또한 이 작업이 완료되기 전까지 이 작업을 할 수 있는 여유 공간이 있어야 작업을 할 수 있다.
(대상 테이블을 복사하고 Live Tuple 만 복사한 테이블에 추가하는 방식이기 때문)



## VACUUM 의 필요성

### 디스크 여유 공간 확보

PostgreSQL 에서는 MVCC 구현을 위해 update 동작을 다음과 같이 실행하게 된다.

1. FSM(FreeSpaceMap, 사용 가능한 공간을 표시한 지도 같은 역할)에 사용 가능한 공간이 있는지 확인, 없으면 FSM을 추가 확보
2. FSM의 사용 가능한 공간에 update된 데이터를 기록함(마치 insert처럼 동작함)
3. update된 데이터의 저장이 완료되면 update 이전의 원본 Tuple을 가리키던 포인터를 새로 update된 Tuple을 가리키도록 변경함

위 과정에서 update가 완료되면 기존 원본 데이터를 저장한 Tuple은 어디에도 참조되지 않는 Tuple이 되는데
이를 쓸모없는, 죽은 데이터라는 의미로 Dead Tuple이라고 한다.

문제는 이 Dead Tuple이 자동으로 정리되거나 FSM으로 반환되지 않기 때문에 쓸데없이 공간만 차지할 뿐만 아니라,
쓸데없이 공간만 차지하는 Dead Tuple 때문에 DB는 더 많은 page를 읽게 되고 이는 쿼리 성능에도 악영향을 끼친다.

VACCUM 작업을 통해 이러한 Dead Tuple 을 제거할 수 있다.


### 실행계획 통계 정보 갱신

PostgreSQL 쿼리 실행 계획기는 쿼리의 좋은 실행 계획을 짜기 위해서 각 테이블에 저장된 자료를 바탕으로 수집된 통계 정보를 이용한다.
이 통계 정보는 ANALYZE 명령을 이용해서 만든다. 또한 VACUUM 명령을 수행하면서 옵션으로 이 작업을 할 수 있다.
이 통계 정보 갱신 작업이 제대로 되지 않으면 의도 되지 않은 쿼리 실행 계획이 짜여질 것이고,
이것으로 전체적으로 데이터베이스 성능을 떨어뜨리는 결과를 초래하기 때문에, 바른 통계 정보 갱신 작업을 주기적으로 하는 것은 중요하다.
통계 정보 갱신 작업도 디스크 여유 공간 확보를 위한 vacuum 작업과 마찬가지로 테이블의 자료 변화량이 많은 경우는 보다 빈번하게, 그 반대인 경우는 좀 더 드물게 진행됨이 좋다.

ANALYZE 명령을 사용자가 직접 실행 할 때는, 한 테이블의 특정 칼럼 정보에 대해서만 통계 정보를 갱신하도록 할 수도 있다.
이렇게 함으로 위에서 언급한 것 처럼 칼럼별 통계 정보 갱신 작업 빈도를 칼럼별로 조절할 수 있다.



### 트랜잭션 ID 겹침 오류 방지

PostgreSQL에서는 트랜잭션 자료에 대한 MVCC 기법은 트랜잭션 ID (XID)를 숫자로 처리하고 그것을 비교하는 방식이다.
한 로우의 자료 입력 XID 값이 현재 트랜잭션 XID 보다 더 크다면 "앞으로 생길" 자료이며, 현재 트랜잭션에서는 보이지 말아야할 자료임을 뜻한다.
그런데, 이 트랜잭션 ID는 32bit 정수형 크기이며, 이 값은 하나의 클러스터 기준으로 관리되기 때문에,
서버가 오랫 동안 운영 되었다면(40억 트랜잭션을 넘게 사용했다면) 트랙잭션 ID 겹침 오류를 발생할 수 있다.
트랙잭션 ID 계산기가 40억을 넘어 다시 0부터 시작하려고 하면, 보관 되어 있는 모든 자료의 XID 값이 0보다 크기 때문에, 모든 자료는 보이지 말아야할 자료로 처리할 것이다.
이런 문제를 방지하기 위해서, 모든 데이터베이스의 모든 테이블에 대해서 20억 트랜잭션을 사용하기 전에 vacuum 작업이 필요하다.


### 인덱스 갱신

지도 정보는 인덱스 전용 쿼리들에 대해서 빠른 응답을 제공하는데 사용된다.
PostgreSQL의 인덱스에는 실자료들에 대해서만 따로 모아서 그 정보를 제공하지 않는다.
즉, 어떤 자료를 해당 세션에게 보여 주어야 할지를 결정 하는 정보는 그 자료의 테이블 페이지까지 살펴 보아야 알 수 있다.
인덱스 전용 검색인 경우는 테이블 페이지를 검색하지 않고 먼저 이 실자료 지도를 검색해서,
이곳에 해당 자료가 있다면 그것을 사용한다. 그만큼 테이블 페이지 읽기 작업을 줄일 수 있는 있다.
특히나 테이블 크기가 큰 경우라면, 디스크 읽기 작업을 상당히 줄이는 효과를 볼 수 있다.
왜냐하면, 실제 테이블 페이지 보다, 이 실자료 지도의 크기는 훨씬 작기 때문이다.



## Reference

https://www.postgresql.kr/docs/9.3/routine-vacuuming.html